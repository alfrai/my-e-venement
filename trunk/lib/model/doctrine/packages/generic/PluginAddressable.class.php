<?php
/**********************************************************************************
*
*	    This file is part of e-venement.
*
*    e-venement is free software; you can redistribute it and/or modify
*    it under the terms of the GNU General Public License as published by
*    the Free Software Foundation; either version 2 of the License.
*
*    e-venement is distributed in the hope that it will be useful,
*    but WITHOUT ANY WARRANTY; without even the implied warranty of
*    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*    GNU General Public License for more details.
*
*    You should have received a copy of the GNU General Public License
*    along with e-venement; if not, write to the Free Software
*    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*
*    Copyright (c) 2006-2013 Baptiste SIMON <baptiste.simon AT e-glop.net>
*    Copyright (c) 2006-2013 Libre Informatique [http://www.libre-informatique.fr/]
*
***********************************************************************************/
?>
<?php

/**
 * PluginAddressable
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    e-venement
 * @subpackage model
 * @author     Baptiste SIMON <baptiste.simon AT e-glop.net>
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
abstract class PluginAddressable extends BaseAddressable
{
  // a major Doctrine hack to permit using indexes within inheritance
  public function index($name, array $definition = array()) 
  {
    $name = str_replace('%CLASS%', method_exists($this, 'getIndexesPrefix') ? $this->getIndexesPrefix() : $this->getTable()->getInstance()->getTableName(), $name);
    return parent::index($name, $definition);
  }
  
  // to avoid recording any UID = ''
  public function preSave($event)
  {
    if ( !$this->vcard_uid )
      $this->vcard_uid = NULL;
    
    // auto-adding user's auto-groups
    if ( sfContext::hasInstance() && $this->hasRelation('Groups') )
    foreach ( sfContext::getInstance()->getUser()->getGuardUser()->AutoGroups as $group )
    {
      $users = array();
      foreach ( $group->Users as $user )
        $users[] = $user->id;
      
      if ( in_array(sfContext::getInstance()->getUser()->getId(), $users) )
        $this->Groups[] = $group;
    }
    
    parent::preSave($event);
  }

/**
 * function getVCard()
 * generates a vCard from Contact $this
 * It is optimized for the Zimbra data structure but fits to the vCard standard.
 *
 * Reversible fields:
 *  * n:LastName / Contact::name
 *  * n:;FirstName / Contact::firstname
 *  * n:;;;Prefixes / Contact::title
 *  * adr:;;StreetAddress / Contact::address
 *  * adr:;;;Locality / Contact::address
 *  * adr:;;;;;PostalCode / Contact::postalcode
 *  * adr:;;;;;;Country / Contact::country
 *  * tel: / Contact::Phonenumbers -- with smart/random updates from CardDAV to e-venement
 *  * email: / Contact::email -- with smart/random updates from CardDAV to e-venement (under the condition that orders have not changed or changes are understandable)
 *  * rev: / Contact::updated_at
 *  * note: / Contact::description
 *  * uid: / Contact::vcard_uid
 *
 * Non-reversible fields (will be resetted on every change in the e-venement datas)
 *  * org:
 *  * adr:;;;;Region
 *  * adr:TYPE=WORK
 *  * fn:
 *
 */
  /**
   * sets the current Addressable object's properties with a given vCard
   * @param bool $pro defines whether or not the address and the email have to be pro or personal...
   * @return PluginAddressable $this
   **/
  public function setVcard($vcard, $pro = false)
  {
    if (!( $vcard instanceof liVCard ))
      $vcard = new liVCard($vcard);
    
    $this->name = $vcard['n']['LastName'];
    
    // getting back the first private address
    $tmp_adrs = array();
    $adrs = !isset($vcard['adr'][0]) ? array($vcard['adr']) : $vcard['adr'];
    foreach ( $adrs as $adr )
    if (!isset($adr['Type']) || isset($adr['Type']) && in_array($pro ? 'work' : 'home', $adr['Type']) )
      $tmp_adrs[] = $adr['Value'];
    if ( isset($tmp_adrs[0]) )
    {
      $adr = $tmp_adrs[0];
      $this->address    = liVCard::vcfNLToRealNL($adr['StreetAddress']);
      $this->city       = $adr['Locality'];
      $this->postalcode = $adr['PostalCode'];
      $this->country    = $adr['Country'];
    }
    
    // getting back the first private email
    $tmp_emails = array();
    $emails = !isset($vcard['email'][0]) ? array($vcard['email']) : $vcard['email'];
    foreach ( $emails as $email )
    if (!isset($email['Type']) || isset($email['Type']) && in_array('pref', $email['Type']) )
      $tmp_emails[] = $email['Value'];
    foreach ( $tmp_emails as $email )
    if ( trim($email) )
    {
      $this->email = trim($email);
      break;
    }
    
    // updated_at
    $this->updated_at = $vCard['rev'];
    
    return $this;
  }
  
  /**
   * get the current Addressable object as a vCard
   * @param bool $pro defines whether or not the address and the email are pro...
   * @return liVCard
   **/
  public function getVcard($pro = false)
  {
    $vCard = new liVCard;
    
    $vCard['fn'] = (string)$this;
    $vCard['n']  = array(
      'LastName'  => $this->name,
    );

    $vCard['adr'] = array(
      'StreetAddress' => liVCard::realNLToVcfNL($this->address),
      'Locality'      => $this->city,
      'PostalCode'    => $this->postalcode,
      'Region'        => $this->region,
      'Country'       => $this->country,
      'Type'          => array($pro ? 'work' : 'home', 'postal', 'parcel'),
    );
    
    if ( trim($this->email) )
    $vCard['email'] = array(
      'Value' => $this->email,
      'Type'  => array('pref','internet'),
    );
    
    if ( sfConfig::get('app_carddav_sync_timezone_hack', false) )
    {
      $time = strtotime($this->updated_at);
      $vCard['rev'] = date('Y-m-d',$time).'T'.date('H:i:s',$time).'Z';
    }
    else
      $vCard['rev'] = $this->updated_at_iso_8601;
    
    // END
    return $vCard;
  }
}
